

# 核心概念

使用etlpy，先介绍以下核心概念：

# 数据流(generator)

etlpy特别适合批量处理数据，我们称为数据流，典型的数据流如：

- 数组(数组元素可能是类的实例化对象，但最常见的是字典)，
- 一行行的文本
- Excel，pandas的DataFrame表格
- 1000个web请求

它们共同的特征是每个元素都很相似，能通过迭代器访问。为了简化讨论，我们处理的就是字典的迭代器。想象一个工作流，它能不断地生成和加工字典，最后将字典输出。

## 属性(property)

一个字典如 `{'a':22,'b':33}`，那么a,b就是字典的键，如果有多个字典，都有a,b两个属性，就能形成表格，a,b就是列了，因此属性和列，可认为是一个概念。

真实的数据处理，一般都会对某个特定属性做连续操作。当let指定了某些列后，之后所有的操作都针对这些列，直到重新设定了列，被操作的列称为目标列，这样可以简化代码.

### 算子(tool)

算子可以对字典做修改，所有的算子分为四种类型：

- 生成器（GE）:如生成100个字典，键为p，值为‘1’到‘100’
- 转换器（TF）:如将'地址'列中的数字提取到'电话'列中
- 过滤器（FT）:如过滤所有某一列的值为空的的字典
- 执行器（GE）:如将所有的字典存储到MongoDB中。
- 排序器 (ST):如将数据流按a列进行降序排列


算子可以类比于加法和乘法等基本操作。etlpy提供了简单方便的文件读写，web访问等算子，你也可以方便地扩展其他工具来增强功能。

绝大多数算子都包含一个最常用参数，它作用在目标列上，个别算子包含一些可选参数。例如:

```
task().create(datas).a.split(',')   #split的参数就是分割字符，作用在a列
```

参数也可以从其他列读取，上面的代码等价于（具体参考`表达式章节`）：
```
task().create(datas).p.set(',').a.split('[p]')   #等价于上面的值，方括号表达式指代从其他列读取
```


> 算子的设计，尽量追求功能正交化，只实现一个功能，一般算子作用于目标列，参数为默认参数(一部分算子会作用在整个流或者数据上)。


## 任务(task)

所有的任务都以task()来定义，通过组合不同的算子，就能定义完整的task.

通常来说，task都以生成器开头:
```
generator= task('task_name').let('p').create(range(1,20))

for r in t:
    print r

# 等价于:
def generator():
    for i in range(1,20):
        yield {'p':i}
for r in generator():
    print r
 

```
task()函数的参数即该任务的名称,每个任务都需要独一无二的名称，默认为'task'

任务可以理解为函数，可以定义多个任务，父任务可调用子任务。任务也可以调用自身。任务能够被切分，或者保存为json等格式，在网络上传输。

> 之后的示例代码为了简化，可能会省略`task()`开头。


### 执行task

创建task并不会使其执行，它是惰性的。etlpy提供了非常简洁明了的调用方法：

先创建一个任务：`t=task().... # 省略之后的算子`

可以用迭代器，依次访问生成的每个元素：
```
for item in t:
    print t
```

可以直接调用，参数为使能p个etl算子（参考`日志和调试`一节)，生成字典数组：

`item_list= t(100) `

可以将task导出为json,yaml，同样也能通过json导入:

```
js= task.to_json()
t2=task().load_json(js)
```  

task还可以通过字符串构建，例如:

`t=task().eval('p.range(1,10).format('{}{}')')`

多个task可以直接相加:

`t1+=t2`等价于`t1.subge(t2,mode='+')`

### 工程(project)

一个工程维护了多个任务，这些任务互相可能有依赖。工程也提供了一个环境(env)。例如，一些算子需要读取字典(比如请求头)作为参数，反复地创建字典并传递是不方便的，可将该字典放在工程中。
```
p=project()
p.env['header']={'header': 'abc'}
t=task().let('t').create(['url']).get(header='header')
#这样就访问了工程里的header参数。
```

使用`from etlpy import *` ，就会创建默认的工程。 

同样的，工程也能保存为json或从json导入，方法同task。




