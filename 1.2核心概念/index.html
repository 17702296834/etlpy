<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>1.2核心概念 - etlpy doc</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "1.2\u6838\u5fc3\u6982\u5ff5";
    var mkdocs_page_input_path = "1.2\u6838\u5fc3\u6982\u5ff5.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> etlpy doc</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">1.综述</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../1.1快速入门/">1.1快速入门</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">1.2核心概念</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#_1">核心概念</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#generator">数据流(generator)</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#core-concepts">Core Concepts</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#generator_1">generator</a></li>
        
            <li><a class="toctree-l3" href="#property">属性(property)</a></li>
        
            <li><a class="toctree-l3" href="#tool">算子(tool)</a></li>
        
            <li><a class="toctree-l3" href="#task">任务(task)</a></li>
        
            <li><a class="toctree-l3" href="#param">参数(param)</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../1.3几种表达式/">1.3几种表达式</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../2.0算子/">2.0算子</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../2.1生成器/">2.1生成器</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../2.2转换器/">2.2转换器</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../2.3爬虫转换器/">2.3爬虫转换器</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../2.4过滤和排序器/">2.4过滤和排序器</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../2.5执行器和数据库/">2.5执行器和数据库</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../2.6自定义算子/">2.6自定义算子</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../2.7子任务/">2.7子任务</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../2.8 参数系统/">2.8 参数系统</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../3.并行化/">3.并行化</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../4.日志和调试/">4.日志和调试</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../5.pandas集成/">5.pandas集成</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../6.代码说明和原理/">6.代码说明和原理</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../7.补充说明/">7.补充说明</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">etlpy doc</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>1.2核心概念</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="_1">核心概念</h1>
<p>使用etlpy，先介绍以下核心概念：</p>
<h2 id="generator">数据流(generator)</h2>
<p>etlpy特别适合批量处理数据，我们称为数据流，典型的数据流如：</p>
<ul>
<li>数组(数组元素可能是字典或对象)，</li>
<li>一行行的文本</li>
<li>Excel，pandas的DataFrame表格</li>
<li>1000个web请求</li>
</ul>
<p>它们共同的特征是每个元素都很相似，能通过迭代器访问。为了简化讨论，我们处理的就是字典的迭代器。想象一个工作流，它能不断地生成和加工字典，最后将字典输出。</p>
<h1 id="core-concepts">Core Concepts</h1>
<p>Before detailed introductions, we will list core concepts as follows:</p>
<h2 id="generator_1">generator</h2>
<h2 id="property">属性(property)</h2>
<p>一个字典如 <code>{'a':22,'b':33}</code>，那么a,b就是字典的键，如果有多个字典，都有a,b两个属性，就能形成表格，a,b就是列了，因此<code>属性</code>和<code>列</code>，可认为是一个概念。</p>
<p>真实的数据处理，一般都会对某个特定属性做连续操作。当let和其他算子指定了某些列后（可以设置多个），etlpy就会记住这个列名，之后所有的操作都针对这些列，直到重新设定了列，被操作的列称为目标列，这样可以简化代码.</p>
<h2 id="tool">算子(tool)</h2>
<p>算子(op)可以对字典做修改，所有的算子分为四种类型：</p>
<ul>
<li>生成器（GE）:如生成100个字典，键为p，值为‘1’到‘100’</li>
<li>转换器（TF）:如将'地址'列中的数字提取到'电话'列中</li>
<li>过滤器（FT）:如过滤所有某一列的值为空的的字典</li>
<li>执行器（GE）:如将所有的字典存储到MongoDB中。</li>
<li>排序器 (ST):如将数据流按a列进行降序排列</li>
</ul>
<p>算子可以类比于加法和乘法等基本操作。etlpy提供了简单方便的文件读写，web访问等算子，你也可以方便地扩展其他工具来增强功能。</p>
<p>绝大多数算子都包含一个最常用参数，它作用在目标列上，个别算子包含一些可选参数。例如:</p>
<pre><code>task().create(datas).a.split(',')   #split的参数就是分割字符，作用在a列
</code></pre>

<p>参数也可以从其他列读取，上面的代码等价于（具体参考<code>表达式章节</code>）：</p>
<pre><code>task().create(datas).p.set(',').a.split('[p]')   #等价于上面的值，方括号表达式指代从其他列读取
</code></pre>

<blockquote>
<p>算子的设计，尽量追求功能正交化，只实现一个功能，一般算子作用于目标列，参数为默认参数(一部分算子会作用在整个流或者数据上)。</p>
</blockquote>
<h2 id="task">任务(task)</h2>
<p>所有的任务都以task()来定义，通过组合不同的算子，就能定义完整的task.</p>
<p>通常来说，task都以生成器开头:</p>
<pre><code>generator= task('task_name').let('p').create(range(1,20))

for r in t:
    print r

# 等价于:
def generator():
    for i in range(1,20):
        yield {'p':i}
for r in generator():
    print r


</code></pre>

<p>task()函数的参数即该任务的名称,每个任务都需要独一无二的名称，默认为'task'</p>
<p>任务可以理解为函数，可以定义多个任务，父任务可调用子任务。任务也可以调用自身。任务能够被切分，或者保存为json等格式，在网络上传输。</p>
<blockquote>
<p>之后的示例代码为了简化，可能会省略<code>task()</code>开头。</p>
</blockquote>
<p>创建task并不会使其执行，它是惰性的。etlpy提供了非常简洁明了的调用方法：</p>
<p>先创建一个任务：<code>t=task().... # 省略之后的算子</code></p>
<p>可以用迭代器，依次访问生成的每个元素：</p>
<pre><code>for item in t:
    print t
</code></pre>

<p>可以直接调用，参数为获取该流的前n个元素，生成字典数组：</p>
<p><code>item_list= t(100)</code></p>
<p>可以将task导出为json,yaml，同样也能通过json导入:</p>
<pre><code>js= task.to_json()
t2=task().load_json(js)
</code></pre>

<p>task还可以通过字符串构建，例如:</p>
<p><code>t=task().eval('p.range(1,10).format('{_}{_}')')</code></p>
<p>多个task可以直接相加:</p>
<p><code>t1+=t2</code>等价于<code>t1.subge(t2,mode='+')</code> 即把任务直接拼接起来。</p>
<p>也可以相乘，等价于元素各自做笛卡尔积：<code>t1*=t2</code></p>
<p>也可以求或，等价于两边的数据表横向拼接: <code>t1|=t2</code></p>
<h2 id="param">参数(param)</h2>
<p>对算子可能需要传参，若要传的参数较多，会影响可读性，若很多算子都使用相似的参数，那么就更难控制了：</p>
<p><code>t=task().get(url='123',cookie='xxx')...get(url='234',cookie='xxx',data=None)</code></p>
<p>因此，考虑将传给算子的参数重新包装，作为字典，那么参数传递就变得很容易了：</p>
<pre><code>p= Param(url='123',cookie='xxx')
`t=task().get(p)...get(p)`
</code></pre>

<p>param是具有树结构的字典，key为参数名，值为str/int/lambda,也可以是另一个param。 当param被求值时(p.eval())，它才会递归地计算其中所有的值，最终输出一个POCO类型的字典。</p>
<p>目前etlpy提供了几种默认的param类型，足以满足大部分需要： 从数组中随机选择值（可用于代理随机分配），或lambda表达式，或从目前的数据流里动态求值（使用<code>[]</code>表达式）。</p>
<p>param最有趣的地方在于，你可以为param来merge新的参数，生成新的param。如下图所示，b比a多了cookie。这样就能适应复杂多变的为算子传递参数的需求。</p>
<p>TODO: 需要画图</p>
<h3 id="project">工程(project)</h3>
<p>一个工程维护了多个任务，这些任务互相可能有依赖。工程包含了默认的环境(env)，包含了所有的task和param。</p>
<p>工程是任务离线保存的最小单元，它也能被保存为json,yaml等用于网络传输等用途，并完整地序列化出等价的project。</p>
<p>使用<code>from etlpy import *</code> ，就会创建默认的工程。 </p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../1.3几种表达式/" class="btn btn-neutral float-right" title="1.3几种表达式">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../1.1快速入门/" class="btn btn-neutral" title="1.1快速入门"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../1.1快速入门/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../1.3几种表达式/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
